/*********
  Rui Santos
  Complete project details at https://randomnerdtutorials.com  
*********/

#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

#include "buttonDetection.h"

#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 64 // OLED display height, in pixels

// Declaration for an SSD1306 display connected to I2C (SDA, SCL pins)
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);

static const unsigned char PROGMEM boot1 [] = {
	// 'boot1, 36x52px
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x03, 0xfc, 0x00, 0x00, 0x00, 
	0x0f, 0x3e, 0x00, 0x00, 0x00, 0x72, 0x09, 0x00, 0x00, 0x00, 0x2f, 0xfc, 0x80, 0x00, 0x00, 0x0f, 
	0xdd, 0x80, 0x00, 0x00, 0x3f, 0xdc, 0x80, 0x00, 0x00, 0x2f, 0xbc, 0x00, 0x00, 0x00, 0x6b, 0xbc, 
	0x00, 0x00, 0x00, 0x73, 0xff, 0x00, 0x00, 0x00, 0x73, 0xff, 0x00, 0x00, 0x00, 0x1f, 0x3f, 0x00, 
	0x00, 0x00, 0x0e, 0x1c, 0x00, 0x00, 0x00, 0x10, 0xf8, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 
	0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x0c, 0x19, 0x80, 0x00, 0x00, 
	0x63, 0xe7, 0xc0, 0x00, 0x00, 0xf3, 0x9f, 0xe0, 0x00, 0x01, 0xf3, 0xbf, 0xf0, 0x00, 0x03, 0xf7, 
	0xbf, 0xf8, 0x00, 0x03, 0x77, 0xbf, 0xfc, 0x00, 0x07, 0xb7, 0xbf, 0xfc, 0x00, 0x0f, 0xb7, 0xbd, 
	0xfe, 0x00, 0x0f, 0x33, 0xbf, 0x7e, 0x00, 0x0e, 0x13, 0xbf, 0x3f, 0x00, 0x0c, 0x13, 0xbe, 0x1f, 
	0x00, 0x30, 0x03, 0x80, 0x8f, 0x80, 0x10, 0x1f, 0xff, 0x07, 0x80, 0x10, 0x07, 0xfc, 0x03, 0x00, 
	0x00, 0x18, 0x01, 0x80, 0xc0, 0x00, 0x0d, 0xff, 0x87, 0xc0, 0x00, 0x0d, 0xff, 0x83, 0x80, 0x00, 
	0x05, 0xff, 0x82, 0x00, 0x00, 0x01, 0xff, 0x00, 0x00, 0x00, 0x01, 0xff, 0x00, 0x00, 0x00, 0x01, 
	0xff, 0x00, 0x00, 0x00, 0x01, 0xfe, 0x00, 0x00, 0x00, 0x01, 0xfe, 0x80, 0x00, 0x00, 0x03, 0xfc, 
	0xc0, 0x00, 0x00, 0x03, 0xfd, 0xe0, 0x00, 0x00, 0x03, 0xf9, 0xf0, 0x00, 0x00, 0x07, 0xfb, 0xf0, 
	0x00, 0x00, 0xe3, 0xf1, 0xc0, 0x00, 0x00, 0xf0, 0xe0, 0x10, 0x00, 0x00, 0x78, 0x60, 0xe0, 0x00, 
	0x00, 0x39, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00
};
const unsigned char boot2 [] PROGMEM = {
	// 'boot2 (3), 36x52px
	0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x07, 0xfe, 0x00, 0x00, 0x00, 
	0x7f, 0x1f, 0x80, 0x00, 0x00, 0x7b, 0xe4, 0xc0, 0x00, 0x00, 0x4f, 0xff, 0x40, 0x00, 0x00, 0x6f, 
	0x9e, 0xc0, 0x00, 0x00, 0x7f, 0xfe, 0xc0, 0x00, 0x00, 0x4d, 0xbe, 0x00, 0x00, 0x00, 0x7b, 0xbd, 
	0x80, 0x00, 0x00, 0xf7, 0xff, 0x80, 0x00, 0x00, 0x7f, 0xf7, 0x80, 0x00, 0x00, 0x1a, 0x1e, 0x00, 
	0x00, 0x00, 0x37, 0xdc, 0x00, 0x00, 0x00, 0x3d, 0xf8, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 
	0x00, 0x07, 0xf7, 0x00, 0x00, 0x00, 0x1c, 0x1e, 0xc0, 0x00, 0x00, 0x1f, 0xfd, 0xe0, 0x00, 0x00, 
	0x73, 0xe7, 0xf0, 0x00, 0x00, 0xff, 0xbf, 0xf0, 0x00, 0x01, 0xf7, 0xbf, 0xfc, 0x00, 0x03, 0x77, 
	0xbd, 0xbc, 0x00, 0x07, 0x76, 0xbf, 0xfe, 0x00, 0x07, 0xb7, 0xb3, 0xda, 0x00, 0x0f, 0xb7, 0xbd, 
	0xff, 0x00, 0x0f, 0xb7, 0xbf, 0x7f, 0x00, 0x1f, 0x3f, 0xff, 0xbf, 0x80, 0x16, 0x1b, 0xbf, 0x9f, 
	0x80, 0x38, 0x1f, 0xc9, 0xcf, 0x80, 0x2a, 0x3f, 0xff, 0xcf, 0x80, 0x1a, 0x13, 0xfc, 0x46, 0x80, 
	0x13, 0x1c, 0x03, 0xc2, 0xc0, 0x0c, 0x3f, 0xff, 0xcf, 0xc0, 0x00, 0x1c, 0xff, 0x87, 0x40, 0x00, 
	0x0d, 0xff, 0x03, 0x00, 0x00, 0x03, 0xfe, 0x04, 0x00, 0x00, 0x07, 0xf8, 0x04, 0x00, 0x00, 0x0f, 
	0xe2, 0x00, 0x00, 0x00, 0x0f, 0xfe, 0x00, 0x00, 0x00, 0x07, 0xfd, 0x00, 0x00, 0x00, 0x03, 0xfd, 
	0x00, 0x00, 0x00, 0x01, 0xb9, 0x80, 0x00, 0x00, 0x00, 0xfa, 0x00, 0x00, 0x00, 0x00, 0x36, 0x80, 
	0x00, 0x00, 0x00, 0x06, 0x80, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x79, 0x80, 0x00, 
	0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00
};


static const unsigned char boot3 [] PROGMEM = {
	// 'boot3 (1), 36x52px
	0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x07, 0xfc, 0x00, 0x00, 0x00, 0x1f, 0x7f, 0x00, 0x00, 0x01, 
	0xf8, 0x1f, 0x80, 0x00, 0x00, 0xef, 0xe8, 0xc0, 0x00, 0x00, 0xbf, 0xfe, 0xc0, 0x00, 0x00, 0x6f, 
	0x9e, 0xc0, 0x00, 0x00, 0xff, 0xfd, 0x00, 0x00, 0x00, 0xdb, 0x3d, 0x00, 0x00, 0x00, 0xf3, 0xff, 
	0x00, 0x00, 0x00, 0xe7, 0xf7, 0x80, 0x00, 0x00, 0xff, 0x7f, 0x80, 0x00, 0x00, 0x9d, 0x1e, 0x00, 
	0x00, 0x00, 0x77, 0xfc, 0x00, 0x00, 0x00, 0x7b, 0xf8, 0x00, 0x00, 0x00, 0x1f, 0xe2, 0x00, 0x00, 
	0x00, 0x06, 0xf6, 0x80, 0x00, 0x00, 0x08, 0x9e, 0xc0, 0x00, 0x00, 0x3f, 0x79, 0xe0, 0x00, 0x00, 
	0x77, 0xcf, 0xf0, 0x00, 0x00, 0xf7, 0xbf, 0xf0, 0x00, 0x00, 0xef, 0x7f, 0xf0, 0x00, 0x00, 0x6f, 
	0x7f, 0xf0, 0x00, 0x00, 0x7f, 0x7f, 0xf0, 0x00, 0x00, 0x6f, 0x7f, 0xe0, 0x00, 0x00, 0x2f, 0x6e, 
	0xe0, 0x00, 0x00, 0x2e, 0xef, 0xe0, 0x00, 0x00, 0x2e, 0x6f, 0x60, 0x00, 0x00, 0x1f, 0x6f, 0xc0, 
	0x00, 0x00, 0x1f, 0x5d, 0x98, 0x00, 0x00, 0x3f, 0x9f, 0x8c, 0x00, 0x00, 0x1f, 0xdf, 0x8c, 0x00, 
	0x00, 0x31, 0xbe, 0x70, 0x00, 0x00, 0x3c, 0x3e, 0x70, 0x00, 0x00, 0x3f, 0xc9, 0xf0, 0x00, 0x00, 
	0x7c, 0xfd, 0xf0, 0x00, 0x00, 0x7b, 0xb7, 0xe0, 0x00, 0x00, 0x66, 0x67, 0xb0, 0x00, 0x00, 0x71, 
	0x9f, 0xe0, 0x00, 0x00, 0x7f, 0xde, 0xc0, 0x00, 0x00, 0xff, 0xdf, 0x9c, 0x00, 0x00, 0xff, 0x8f, 
	0xfc, 0x00, 0x00, 0xff, 0x07, 0xfc, 0x00, 0x01, 0xff, 0x07, 0xfc, 0x00, 0x79, 0xfa, 0x01, 0xf8, 
	0x00, 0x3c, 0xee, 0x00, 0xf2, 0x00, 0x3e, 0xbc, 0x00, 0x44, 0x00, 0x1f, 0x58, 0x00, 0xfc, 0x00, 
	0x0f, 0x60, 0x01, 0xf0, 0x00, 0x01, 0xa0, 0x03, 0xc0, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00
};




const int bootChangeInterval = 5000;  // Intervalo de cambio en milisegundos (ej. 5000 ms = 5 segundos)
unsigned long lastBootChangeTime = 0;  // Último tiempo de cambio de imagen
int currentBootImage = 0;  // Índice de la imagen actual (0 = boot1, 1 = boot2, 2 = boot3)
bool bootImageChanged = true;  // Indica si se cambió la imagen en la última iteración



const int pinPot1 = A0;
const int pinPot2 = A1;
const int pinPot3 = A2;

const int buttonPin1 = 7;
const int buttonPin2 = 6;
const int buttonPin3 = 5;
const int buttonPin4 = 4;

int ledPin1 = 8;
int ledPin2 = 2;
int ledPin3 = 3;

String MainMenuText = "";

byte lastPot1Value = 0;


//Actividad de los inputs (Potenciómetros y botones)

bool button1Status = false;
bool button2Status = false;
bool button3Status = false;
bool button4Status = false;


void setup() {
  Serial.begin(9600);
  
  pinMode(pinPot1, INPUT);
  pinMode(pinPot2, INPUT);
  pinMode(pinPot3, INPUT);

  pinMode(buttonPin1, INPUT_PULLUP);
  pinMode(buttonPin2, INPUT_PULLUP);
  pinMode(buttonPin3, INPUT_PULLUP);
  pinMode(buttonPin4, INPUT_PULLUP);

  pinMode(ledPin1, OUTPUT);
  pinMode(ledPin2, OUTPUT);
  pinMode(ledPin3, OUTPUT);

  if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { // Address 0x3D for 128x64
    Serial.println(F("SSD1306 allocation failed"));
    for(;;);
  }
  delay(2000);
  display.clearDisplay();

  
  
  // Display static text
  for(int i = 5; i < 6; i++){
    
    display.setTextSize(1);
  display.setTextColor(WHITE); 
  display.setCursor(38, 25);
    display.println("Cargando");
    for(int i=40; i<=90; i++){
      display.drawPixel(i,35, WHITE);
      display.display(); 
    }
    display.clearDisplay();
  }
  
  
}

void loop() {
  // Leer los valores de los potenciómetros y mapearlos
  unsigned int pot1Full = analogRead(pinPot1);
  unsigned int pot2Full = analogRead(pinPot2);
  unsigned int pot3Full = analogRead(pinPot3);

  byte pot1Value = map(pot1Full, 0, 1023, 0, 5);
  byte pot2Value = map(pot2Full, 0, 1023, 0, 50);
  byte pot3Value = map(pot3Full, 0, 1023, 0, 50);


  // Limpiar la pantalla
  display.clearDisplay();
  MainMenuText = "";

  // Comprueba que el menú sea el mismo y aplica transición si no

  if (pot1Value == 5){

  }else if ( pot1Value != lastPot1Value){
    Transition();
    lastPot1Value = pot1Value;
  } delay(150);

  //display.invertDisplay(true);

  // Dibujar texto e interfaz estática
  
  /*display.drawLine(40, 20, 40, 0, WHITE);
  display.drawLine(122, 20, 122, 0, WHITE);
  display.drawLine(40, 20, 122, 20, WHITE);*/
  display.setTextSize(1);
  display.setTextColor(WHITE); 
  display.setCursor(45, 23);
  display.println("Values: ");

  // Actualizar y dibujar los valores de los potenciómetros
  PotManager(pot1Value, 40, 34);
  PotManager(pot2Value, 60, 34);
  PotManager(pot3Value, 80, 34);
  digitalWrite(ledPin1, LOW);
  digitalWrite(ledPin2, LOW);
  digitalWrite(ledPin3, LOW);
  ButtonManager();
  AnimManager();
  
  switch(pot1Value){
    case 0:
      
      Serial.println("Menú principal");
      display.setTextSize(1);
      display.setTextColor(WHITE); 
      display.setCursor(52, 6);
      display.println(">> Menu");
      display.drawRect(40,2,84,16, WHITE);
      break;
    case 1:
      Serial.println("Inventario");
      display.setTextSize(1);
      display.setTextColor(WHITE); 
      display.setCursor(48, 6);
      display.println("> Inventory");
      display.drawRect(40,2,84,16, WHITE);
      break;
    case 2:
      Serial.println("Misiones");
      display.setTextSize(1);
      display.setTextColor(WHITE); 
      display.setCursor(52, 6);
      display.println("> Quests ..");
      display.drawRect(40,2,84,16, WHITE);
      break;
    case 3:
      Serial.println("Radio");
      display.setTextSize(1);
      display.setTextColor(WHITE); 
      display.setCursor(52, 6);
      display.println("> Radio");
      display.drawRect(40,2,84,16, WHITE);
      break;
    default:
      break;

  }
  
  //Muestra texto de menú principal (feed)
  drawWrappedText(MainMenuText, 40, 42, 13); 

  // Mostrar todo en la pantalla
  display.display();

  // Pequeña pausa para estabilizar el bucle
  delay(150);
  
}




void drawWrappedText(String text, int x, int y, int maxWidth) {
  const int lineHeight = 8;  // Altura de línea para fuente de tamaño 1
  int currentX = x;
  int currentY = y;
  int textLength = text.length();  // Obtener la longitud de la cadena String
  const int charsPerLine = 14;  // Número deseado de caracteres por línea

  for (int i = 0; i < textLength; i += charsPerLine) {
    // Obtener una subcadena de longitud 'charsPerLine'
    String line = text.substring(i, min(i + charsPerLine, textLength));

    // Dibujar la línea en la posición actual
    display.setCursor(currentX, currentY);
    display.print(line);

    // Actualizar la posición Y para la siguiente línea
    currentY += lineHeight;
  }
}

void Transition(){
  
  for (int o = 0; o< 5; o++){
    for (int i = 0; i < 18; i += 3) {
      display.drawLine(0, i*o, 126, i*o, WHITE); // Dibuja una línea horizontal desde (3, i) hasta (122, i)
    }
    display.display();
  }
}

void AnimManager(){
  // Verificar si es tiempo de cambiar la imagen
  unsigned long currentTime = millis();
  if (currentTime - lastBootChangeTime >= bootChangeInterval || bootImageChanged) {
    lastBootChangeTime = currentTime;
    bootImageChanged = false;

    // Cambiar al siguiente bitmap (cíclico: boot1 -> boot2 -> boot3 -> boot1)
    currentBootImage = (currentBootImage + 1) % 3;

    // Dibujar la imagen correspondiente
    switch (currentBootImage) {
      case 0:
        display.drawBitmap(0, 0, boot1, 36, 52, 1);
        break;
      case 1:
        display.drawBitmap(0, 0, boot2, 36, 52, 1);
        break;
      case 2:
        display.drawBitmap(0, 0, boot3, 36, 52, 1);
        break;
    }

    // Indicar que la imagen ha cambiado
    bootImageChanged = true;
  }
}
void PotManager(uint8_t pot, byte x, byte y) {
  // Aquí puedes realizar cualquier operación necesaria con el valor del potenciómetro
  // Por ejemplo, puedes imprimirlo en el monitor serial
  display.setCursor(x, y);
  display.cp437(true);
  display.write(7);
  display.setCursor(x + 6, y );
  display.println(pot);
  
}
